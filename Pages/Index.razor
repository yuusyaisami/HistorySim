@page "/"
@using HistorySim.Game
@inject IJSRuntime JS

<div class="console-root">
  <header class="console-header">
    <h1>HistorySim Console</h1>
    <p>Roguelite prototype â€” type <code>help</code> for commands</p>
  </header>

  <section class="console-output" @ref="_logRef">
    @foreach (var entry in _log)
    {
      <div class="log-line @entry.Kind">@entry.Message</div>
    }
  </section>

  <section class="console-input">
    <span>&gt;</span>
    <input @bind="_input" @bind:event="oninput" @onkeydown="HandleInputKey" @ref="_inputRef" placeholder="enter command..." />
    <button type="button" @onclick="Submit">Enter</button>
  </section>
</div>

@code {
  readonly RogueliteGame _game = new();
  readonly List<LogEntry> _log = new();

  string _input = string.Empty;
  ElementReference _logRef;
  ElementReference _inputRef;
  bool _focusRequested = true;
  bool _scrollPending;

  protected override void OnInitialized()
  {
    Write("Welcome to the HistorySim roguelite console.");
    Write("Type `help` to see available commands.");
  }

  protected override async Task OnAfterRenderAsync(bool firstRender)
  {
    if (_focusRequested)
    {
      _focusRequested = false;
      await _inputRef.FocusAsync();
    }

    if (_scrollPending)
    {
      _scrollPending = false;
      await JS.InvokeVoidAsync("historySim.scrollToBottom", _logRef);
    }
  }

  void HandleInputKey(KeyboardEventArgs args)
  {
    if (args.Key == "Enter")
    {
      Submit();
    }
  }

  void Submit()
  {
    var command = _input.Trim();
    if (string.IsNullOrWhiteSpace(command))
    {
      return;
    }

    Write($"> {command}", "dim");
    _input = string.Empty;
    _focusRequested = true;

    try
    {
      Execute(command);
    }
    catch (Exception ex)
    {
      Write($"Error: {ex.Message}", "err");
    }
  }

  void Execute(string command)
  {
    var parts = command.Split(' ', StringSplitOptions.RemoveEmptyEntries);
    var verb = parts[0].ToLowerInvariant();
    var args = parts.Skip(1).ToArray();

    switch (verb)
    {
      case "help":
        WriteLines(new[]
        {
          "start               - begin a new expedition",
          "options             - show current path choices",
          "choose <1-3>        - pick a path option",
          "status              - view party status",
          "bar                 - display the current action bar",
          "lock [0-100]        - stop the action bar (optional percent)",
          "log                 - echo recent system messages",
          "reset               - reset game state"
        }, "dim");
        break;

      case "start":
        _game.StartNewRun();
        DumpMessages();
        break;

      case "options":
        if (!_game.Options.Any())
        {
          Write("No route options are currently available.", "warn");
        }
        else
        {
          foreach (var line in _game.DescribeOptions())
          {
            Write(line);
          }
        }
        break;

      case "choose":
        if (args.Length == 0 || !int.TryParse(args[0], out var choice))
        {
          Write("Choose expects a number between 1 and 3.", "warn");
          break;
        }
        if (_game.TryChooseOption(choice - 1, out var message))
        {
          Write(message);
          DumpMessages();
        }
        else
        {
          Write(message, "warn");
        }
        break;

      case "status":
        Write(_game.GetStatus(), "dim");
        break;

      case "bar":
        foreach (var line in _game.DescribeActionBar())
        {
          Write(line);
        }
        break;

      case "lock":
        ResolveTurn(args);
        break;

      case "log":
        DumpMessages();
        break;

      case "reset":
        _game.Reset();
        Write("Game state reset.", "warn");
        break;

      default:
        Write("Unknown command. Type `help` for assistance.", "warn");
        break;
    }
  }

  void ResolveTurn(string[] args)
  {
    double? position = null;
    if (args.Length > 0 && double.TryParse(args[0], out var percent))
    {
      position = Math.Clamp(percent / 100.0, 0, 1);
    }

    var turnLog = new List<string>();
    if (_game.TryResolveTurn(position, turnLog, out var combatComplete))
    {
      foreach (var line in turnLog)
      {
        Write(line);
      }

      if (combatComplete)
      {
        DumpMessages();
      }
    }
    else
    {
      foreach (var line in turnLog)
      {
        Write(line, "warn");
      }
    }
  }

  void DumpMessages()
  {
    foreach (var entry in _game.Messages)
    {
      Write(entry);
    }
  }

  void Write(string message, string kind = "")
  {
    _log.Add(new LogEntry(kind, message));
    if (_log.Count > 600)
    {
      _log.RemoveRange(0, _log.Count - 600);
    }
    _scrollPending = true;
    StateHasChanged();
  }

  void WriteLines(IEnumerable<string> lines, string kind = "")
  {
    foreach (var line in lines)
    {
      Write(line, kind);
    }
  }

  record LogEntry(string Kind, string Message);
}
